/**@file
 *     @brief     ALi UDI common function implement
 *     @author    ray.gong
 *     @date        2013-5-21
 *     @version    1.0.0
 *     @note        ali corp. all rights reserved. 2013-2999 copyright (C)
 *                input file detail description here
 *                input file detail description here
 *                input file detail description here
 */

/****************************INCLUDE HEAD FILE************************************/
#include "aui_common_priv.h"
#include "aui_common_list.h"
#include <stdarg.h>
#include <stddef.h>
#include <stdlib.h>
#include <pthread.h>

#include <alipltfintf.h>

#include "../../version_autogenerated.h"
#include "aui_common_priv.h"
#include "aui_common.h"
#include "aui_log.h"

AUI_MODULE(COMMON)

/****************************LOCAL MACRO************************************/
#define INPUT_TASK_PRIORITY       OSAL_PRI_NORMAL
#define INPUT_TASK_STACKSIZE    0x1000
#define INPUT_TASK_QUANTUM          10

/****************************LOCAL TYPE************************************/
/** log handle */
typedef struct aui_st_log_handle
{
    unsigned char *puc_log_buf_addr;
    unsigned long ul_log_buf_len;
    unsigned long ul_log_buf_cur_pos;
    //OSAL_ID sem_log;
}aui_log_handle,*aui_p_log_handle;

/** log handle */
typedef struct aui_st_log_cfg_rd
{
    unsigned char *puc_log_buf_addr;
    unsigned long ul_log_buf_len;
    //OSAL_ID sem_log;
}aui_log_cfg_rd,*aui_p_log_cfg_rd;

/****************************LOCAL VAR************************************/
//static unsigned char *s_uc_log_buf_addr_start=NULL;
//static unsigned long s_ul_log_buf_len=0x80000;
//static OSAL_ID s_msgQId_aui_log;
//static aui_log_handle s_log_hld;

static struct all_hdl {
    struct aui_list_head list;
} all_hdl[AUI_MODULE_LAST];

static int all_hdl_initialized = 0;
static pthread_mutex_t m_aui_common_mutex = PTHREAD_MUTEX_INITIALIZER;

//aui_dev_all g_all_dev_hdl;
//char g_ac_log_string[MBF_SIZE_LOG+1]={0};

/****************************LOCAL FUNC IMPLEMENT************************************/
#if 0
static unsigned char char2hex(unsigned char ch)
{
    unsigned char ret =  - 1;
    if ((ch <= 0x39) && (ch >= 0x30))
    // '0'~'9'
        ret = ch &0xf;
    else if ((ch <= 102) && (ch >= 97))
    //'a'~'f'
        ret = ch - 97+10;
    else if ((ch <= 70) && (ch >= 65))
    //'A'~'F'
        ret = ch - 65+10;

    return ret;
}
#endif

/**
*     @brief         get ALi UDI version
*     @author        ray.gong
*     @date              2013-6-7
*     @param[out]    pul_version point to the ALi UDI version number
*      @return          AUI_RNT_SUCCESS initialize a ring buffer successful
*      @return          AUI_RTN_EINVAL  initialize a ring buffer failed,because input parameters invalid
*      @return          others  initialize a ring buffer failed
*     @note
*
*/
AUI_RTN_CODE aui_version_get(unsigned long *pul_version)
{
    if(NULL==pul_version)
    {
        aui_rtn(AUI_RTN_EINVAL,NULL);
    }
    *pul_version=AUI_VERSION_NUM;
    return AUI_RTN_SUCCESS;
}

/**
*     @brief         get aui package information
*     @author        steven.zhang
*     @date              2017-5-9
*     @param[out]   the buffer for pass the aui package version 
*     @param[out]   the buffer for pass the aui been compiled datetime 
*      @return         AUI_RTN_SUCCESS get the information of aui package successful
*      @return         AUI_RTN_EINVAL  getting the infomation of aui package invalid
*     @note
*
*/
AUI_RTN_CODE aui_log_package_info_get(
	char* package_info,
	int max_len
)
{
	char* package_name = "aui";
	//check the source string
    if((NULL == BR2_AUI_AUTOGENERATE_VERSION) ||
			(NULL == BR2_AUI_COMPILE_DATETIME))
    {
        aui_rtn(AUI_RTN_EINVAL,NULL);
    }

	//check the target pointer.
	if (NULL == package_info)
	{
        aui_rtn(AUI_RTN_EINVAL,NULL);
	}

	MEMSET(package_info, 0x0, max_len);
	//get pacage information from aliplatform
	alipltf_package_info_get(package_info, max_len);
	if((max_len - strlen(package_info)) < strlen(BR2_AUI_AUTOGENERATE_VERSION)){
        aui_rtn(AUI_RTN_EINVAL, "max_len less than string's length!\n");
	}

	//get aui package tat
	snprintf(package_info + strlen(package_info), max_len - strlen(package_info),\
			"%s : %s\n", package_name, BR2_AUI_AUTOGENERATE_VERSION);
	if((max_len - strlen(package_info)) < strlen(BR2_AUI_AUTOGENERATE_VERSION)){
        aui_rtn(AUI_RTN_EINVAL, "max_len less than string's length!\n");
	}
	//get aui compile datetime
	snprintf(package_info + strlen(package_info), max_len - strlen(package_info),\
			"%s : %s\n", package_name, BR2_AUI_COMPILE_DATETIME);
	if((max_len - strlen(package_info)) < strlen(BR2_AUI_COMPILE_DATETIME)){
        aui_rtn(AUI_RTN_EINVAL, "max_len less than string's length!\n");
	}

    return AUI_RTN_SUCCESS;

}

/**
*     @brief         get common module version
*     @author        ray.gong
*     @date              2013-6-7
*     @param[out]    pul_version point to the common module version number
*      @return          AUI_RNT_SUCCESS initialize a ring buffer successful
*      @return          AUI_RTN_EINVAL  initialize a ring buffer failed,because input parameters invalid
*      @return          others  initialize a ring buffer failed
*     @note
*
*/
AUI_RTN_CODE aui_common_version_get(unsigned long *pul_version)
{
    if(NULL==pul_version)
    {
        aui_rtn(AUI_RTN_EINVAL,NULL);
    }
    *pul_version=AUI_MODULE_VERSION_NUM_COMMON;
    return AUI_RTN_SUCCESS;
}

/**
*     @brief         initialize the common module
*     @author        ray.gong
*     @date              2013-5-20
*     @param[in]        p_common_module_attr point to the attribute of common module
*      @return          AUI_RTN_SUCCESS initialize the task module successful
*      @return          AUI_RTN_EINVAL  initialize the task module failed,because input parameters invalid
*      @return          others  initialize the task module failed
*     @note
*
*/
AUI_RTN_CODE aui_common_init(aui_p_common_module_attr p_common_module_attr)
{
    if(NULL==p_common_module_attr)
    {
        aui_rtn(AUI_RTN_EINVAL,NULL);
    }


    return AUI_RTN_SUCCESS;
}

/**
*     @brief         de_initialize the common module
*     @author        ray.gong
*     @date              2013-5-20
*      @return          AUI_RTN_SUCCESS deinitialize the task module successful
*      @return          AUI_RTN_EINVAL  deinitialize the task module failed,because input parameters invalid
*      @return          others  initialize the task module failed
*     @note
*
*/
AUI_RTN_CODE aui_common_de_init()
{
    return AUI_RTN_SUCCESS;
}

#if 1

#define ENTER
#define LEAVE

//static pthread_mutex_t mutex_ring_buf = PTHREAD_MUTEX_INITIALIZER;
/**
*     @brief         initialize a ring buffer
*     @author        ray.gong
*     @modify        fawn.fu @ 20160617  niker.li @ 20161009
*     @date              2013-5-21
*     @param[in]        ul_buf_len ring buffer length
*     @param[out]    p_ring_buf new ring buffer handle
*      @return          AUI_RNT_SUCCESS initialize a ring buffer successful
*      @return          AUI_RTN_EINVAL  initialize a ring buffer failed,because input parameters invalid
*      @return          others  initialize a ring buffer failed
*     @note
*
*/

AUI_RTN_CODE aui_common_init_ring_buf(unsigned long ul_buf_len,aui_ring_buf* p_ring_buf)
{
    ENTER
    p_ring_buf->pby_ring_buf=MALLOC(ul_buf_len);
    if(NULL==p_ring_buf->pby_ring_buf) {
        aui_rtn(AUI_RTN_ENOMEM,NULL);
    }
    MEMSET(p_ring_buf->pby_ring_buf,0,ul_buf_len);
    p_ring_buf->ul_ring_buf_len=ul_buf_len;

    pthread_mutex_t *tmp_mutex = NULL;
    tmp_mutex = (pthread_mutex_t *)MALLOC(sizeof(pthread_mutex_t));
    if(NULL == tmp_mutex) {
        FREE(p_ring_buf->pby_ring_buf);
        aui_rtn(AUI_RTN_ENOMEM,NULL);
    }
    MEMSET(tmp_mutex, 0, sizeof(pthread_mutex_t));
    if (pthread_mutex_init(tmp_mutex, NULL) != 0) {
        FREE(p_ring_buf->pby_ring_buf);
        FREE(tmp_mutex);
        AUI_DBG("Failed init mutex\n");
        LEAVE
        return AUI_RTN_FAIL;
    }
    p_ring_buf->sem_ring = (unsigned int)tmp_mutex;
    p_ring_buf->ul_ring_buf_rd = p_ring_buf->ul_ring_buf_wt = 0;

    AUI_DBG("get ring buf: %p\n", p_ring_buf->pby_ring_buf);
    //p_ring_buf->sem_ring=osal_mutex_create();//OSAL_INVALID_ID;
    LEAVE
    return AUI_RTN_SUCCESS;
}

/**
*     @brief         deinitialize the ring buffer
*     @author        ray.gong
*     @date              2013-5-21
*     @modify        fawn.fu @ 20160617 niker.li @ 20161009
*     @param[in]        p_ring_buf new ring buffer handle
*      @return          AUI_RNT_SUCCESS deinitialize the ring buffer successful
*      @return          AUI_RTN_EINVAL  deinitialize the ring buffer failed,because input parameters invalid
*      @return          others  deinitialize the ring buffer failed
*     @note
*
*/
AUI_RTN_CODE aui_common_un_init_ring_buf(aui_ring_buf* p_ring_buf)
{
    ENTER
    pthread_mutex_lock((pthread_mutex_t *)p_ring_buf->sem_ring);
    if(p_ring_buf->pby_ring_buf) {
        AUI_DBG("free ring buf: %p\n", p_ring_buf->pby_ring_buf);
        FREE(p_ring_buf->pby_ring_buf);
        p_ring_buf->pby_ring_buf=NULL;
    }
    pthread_mutex_unlock((pthread_mutex_t *)p_ring_buf->sem_ring);

    if (pthread_mutex_destroy((pthread_mutex_t *)p_ring_buf->sem_ring) != 0) {
        AUI_DBG("Failed deinit mutex\n");
        LEAVE
        return AUI_RTN_FAIL;
    }
    FREE((pthread_mutex_t *)p_ring_buf->sem_ring);
    LEAVE
    return AUI_RTN_SUCCESS;
}

AUI_RTN_CODE aui_common_rst_ring_buf(aui_ring_buf* p_ring_buf)
{
    ENTER
    pthread_mutex_lock((pthread_mutex_t *)p_ring_buf->sem_ring);
    if(NULL==p_ring_buf->pby_ring_buf)
    {
        pthread_mutex_unlock((pthread_mutex_t *)p_ring_buf->sem_ring);
        LEAVE
        aui_rtn(AUI_RTN_ENOMEM,NULL);
    }
    //AUI_TAKE_SEM(p_ring_buf->sem_ring);

    p_ring_buf->ul_ring_buf_rd = p_ring_buf->ul_ring_buf_wt = 0;

    pthread_mutex_unlock((pthread_mutex_t *)p_ring_buf->sem_ring);//AUI_GIVE_SEM(p_ring_buf->sem_ring);;
    LEAVE
    return AUI_RTN_SUCCESS;
}

/**
*     @brief         get the ring buffer start address
*     @author        ray.gong
*     @date              2013-5-21
*     @modify        fawn.fu @ 20160617
*     @param[in]        p_ring_buf ring buffer handle
*     @param[out]    p_buf_addr point to the ring buffer start address
*      @return          AUI_RNT_SUCCESS get the ring buffer start address successful
*      @return          AUI_RTN_EINVAL  get the ring buffer start address failed,because input parameters invalid
*      @return          others  get the ring buffer start address failed
*     @note
*
*/
AUI_RTN_CODE aui_common_get_ring_buf_base_addr(aui_ring_buf* p_ring_buf,unsigned char** p_buf_addr)
{
    if(NULL==p_ring_buf)
    {
        aui_rtn(AUI_RTN_EINVAL,NULL);
    }

    *p_buf_addr=(unsigned char*)p_ring_buf->pby_ring_buf;
    return AUI_RTN_SUCCESS;
}

/**
*     @brief         get the ring buffer data length
*     @author        ray.gong
*     @date              2013-5-21
*     @modify        fawn.fu @ 20160617
*     @param[in]        p_ring_buf ring buffer handle
*     @param[out]    pul_data_len point to the ring buffer data length
*      @return          AUI_RNT_SUCCESS get the ring buffer data length successful
*      @return          AUI_RTN_EINVAL  get the ring buffer data length failed,because input parameters invalid
*      @return          others  get the ring buffer data length failed
*     @note
*
*/
AUI_RTN_CODE aui_common_ring_buf_data_len(aui_ring_buf* p_ring_buf,unsigned long *pul_data_len)
{
    ENTER
    if((NULL==p_ring_buf)||(NULL==pul_data_len))
    {
        aui_rtn(AUI_RTN_EINVAL,NULL);
    }
    pthread_mutex_lock((pthread_mutex_t *)p_ring_buf->sem_ring);//AUI_TAKE_SEM(p_ring_buf->sem_ring);
    AUI_DBG("ring buf: %p, wt:%ld, rd:%ld\n", p_ring_buf->pby_ring_buf,
        p_ring_buf->ul_ring_buf_wt, p_ring_buf->ul_ring_buf_rd);
    if(p_ring_buf->ul_ring_buf_wt>=p_ring_buf->ul_ring_buf_rd)
    {
        *pul_data_len=p_ring_buf->ul_ring_buf_wt-p_ring_buf->ul_ring_buf_rd;
    }
    else
    {
        *pul_data_len=p_ring_buf->ul_ring_buf_len+p_ring_buf->ul_ring_buf_wt-p_ring_buf->ul_ring_buf_rd;
    }

    pthread_mutex_unlock((pthread_mutex_t *)p_ring_buf->sem_ring);//AUI_GIVE_SEM(p_ring_buf->sem_ring);
    LEAVE
    return AUI_RTN_SUCCESS;
}

AUI_RTN_CODE aui_common_ring_buf_lock(aui_ring_buf* p_ring_buf)
{
    if(NULL==p_ring_buf)
    {
        return AUI_RTN_SUCCESS;
    }

    ENTER
    pthread_mutex_lock((pthread_mutex_t *)p_ring_buf->sem_ring);//AUI_TAKE_SEM(p_ring_buf->sem_ring);;
    return AUI_RTN_SUCCESS;
}

AUI_RTN_CODE aui_common_ring_buf_unlock(aui_ring_buf* p_ring_buf)
{
    if(NULL==p_ring_buf)
    {
        return AUI_RTN_SUCCESS;
    }

    ENTER
    pthread_mutex_unlock((pthread_mutex_t *)p_ring_buf->sem_ring);//AUI_GIVE_SEM(p_ring_buf->sem_ring);;
    return AUI_RTN_SUCCESS;
}

/**
*     @brief         get the ring buffer remain space length
*     @author        ray.gong
*     @date              2013-5-21
*     @modify        fawn.fu @ 20160617
*     @param[in]        p_ring_buf ring buffer handle
*     @param[out]    pul_buf_remain point to the ring buffer remain space length
*      @return          AUI_RNT_SUCCESS get the ring buffer remain space length successful
*      @return          AUI_RTN_EINVAL  get the ring buffer remain space length failed,because input parameters invalid
*      @return          others  get the ring buffer remain space length failed
*     @note
*
*/
AUI_RTN_CODE aui_common_ring_buf_remain(aui_ring_buf* p_ring_buf,unsigned long *pul_buf_remain)
{
    unsigned long ul_data_len=0;

    if((NULL==p_ring_buf)||(NULL==pul_buf_remain))
    {
        aui_rtn(AUI_RTN_EINVAL,NULL);
    }

    if(AUI_RTN_SUCCESS!=aui_common_ring_buf_data_len(p_ring_buf,&ul_data_len))
    {
        aui_rtn(AUI_RTN_FAIL,NULL);
    }

    pthread_mutex_lock((pthread_mutex_t *)p_ring_buf->sem_ring);//AUI_TAKE_SEM(p_ring_buf->sem_ring);;
    *pul_buf_remain=p_ring_buf->ul_ring_buf_len-ul_data_len-1;
    pthread_mutex_unlock((pthread_mutex_t *)p_ring_buf->sem_ring);//AUI_GIVE_SEM(p_ring_buf->sem_ring);

    return AUI_RTN_SUCCESS;
}

/**
*     @brief         read data from ring buffer
*     @author        ray.gong
*     @date              2013-5-21
*     @modify        fawn.fu @ 20160617
*     @param[in]        p_ring_buf ring buffer handle
*     @param[in]        ul_buf_len read data length
*     @param[out]    p_data_out point to the data read from ring buffer
*      @return          AUI_RNT_SUCCESS read data from ring buffer successful
*      @return          AUI_RTN_EINVAL  read data from ring buffer failed,because input parameters invalid
*      @return          OS_RING_RD_NO_DATA  the remain data in ring buffer is less than want to read length
*      @return          others  read data from ring buffer failed
*     @note
*
*/
AUI_RTN_CODE aui_common_ring_buf_rd(aui_ring_buf* p_ring_buf,unsigned long ul_buf_len,unsigned long *pul_real_data_len,unsigned char *p_data_out)
{
    unsigned long ul_buf_len_tmp=0;
    unsigned long ul_data_len=0;
    ENTER
    pthread_mutex_lock((pthread_mutex_t *)p_ring_buf->sem_ring);
    if((NULL==p_ring_buf->pby_ring_buf)||(NULL==p_data_out)||(NULL==pul_real_data_len))
    {
        //*pul_real_data_len = 0;
        pthread_mutex_unlock((pthread_mutex_t *)p_ring_buf->sem_ring);
        LEAVE
        aui_rtn(AUI_RTN_EINVAL,NULL);
    }

    pthread_mutex_unlock((pthread_mutex_t *)p_ring_buf->sem_ring);
    if(AUI_RTN_SUCCESS!=aui_common_ring_buf_data_len(p_ring_buf,&ul_data_len))
    {
        *pul_real_data_len = 0;
        LEAVE
        aui_rtn(AUI_RTN_FAIL,NULL);
    }
    if((ul_buf_len>ul_data_len))
    {
        ul_buf_len_tmp=ul_data_len;
    }
    else
    {
        ul_buf_len_tmp=ul_buf_len;
    }

    pthread_mutex_lock((pthread_mutex_t *)p_ring_buf->sem_ring);//AUI_TAKE_SEM(p_ring_buf->sem_ring);
    AUI_DBG("ring buf: %p, wt:%ld, rd:%ld\n", p_ring_buf->pby_ring_buf,
        p_ring_buf->ul_ring_buf_wt, p_ring_buf->ul_ring_buf_rd);
    if(ul_buf_len_tmp<= p_ring_buf->ul_ring_buf_len-p_ring_buf->ul_ring_buf_rd)
    {
        //osal_cache_invalidate(p_ring_buf->pby_ring_buf+p_ring_buf->ul_ring_buf_rd,ul_buf_len_tmp);
        MEMCPY(p_data_out,
                p_ring_buf->pby_ring_buf+p_ring_buf->ul_ring_buf_rd,
                ul_buf_len_tmp);
        p_ring_buf->ul_ring_buf_rd+=ul_buf_len_tmp;
        if(p_ring_buf->ul_ring_buf_rd==p_ring_buf->ul_ring_buf_len)
        {
            AUI_DBG("rest ul_ring_buf_rd to 0\n");
            p_ring_buf->ul_ring_buf_rd=0;
        }
    }
    else
    {
        //osal_cache_invalidate(p_ring_buf->pby_ring_buf+p_ring_buf->ul_ring_buf_rd,p_ring_buf->ul_ring_buf_len-p_ring_buf->ul_ring_buf_rd);
        MEMCPY(p_data_out,p_ring_buf->pby_ring_buf+p_ring_buf->ul_ring_buf_rd,p_ring_buf->ul_ring_buf_len-p_ring_buf->ul_ring_buf_rd);
        //osal_cache_invalidate(p_ring_buf->pby_ring_buf,ul_buf_len_tmp-(p_ring_buf->ul_ring_buf_len-p_ring_buf->ul_ring_buf_rd));
        MEMCPY(p_data_out +p_ring_buf->ul_ring_buf_len-p_ring_buf->ul_ring_buf_rd ,
        p_ring_buf->pby_ring_buf,
        ul_buf_len_tmp-(p_ring_buf->ul_ring_buf_len-p_ring_buf->ul_ring_buf_rd));
        p_ring_buf->ul_ring_buf_rd=(ul_buf_len_tmp-(p_ring_buf->ul_ring_buf_len-p_ring_buf->ul_ring_buf_rd));
    }
    *pul_real_data_len = ul_buf_len_tmp;
    AUI_DBG("<after read> ring buf: %p, wt:%ld, rd:%ld\n", p_ring_buf->pby_ring_buf,
        p_ring_buf->ul_ring_buf_wt, p_ring_buf->ul_ring_buf_rd);
    pthread_mutex_unlock((pthread_mutex_t *)p_ring_buf->sem_ring);//AUI_GIVE_SEM(p_ring_buf->sem_ring);
    LEAVE
    return AUI_RTN_SUCCESS;
}

/**
*     @brief         write data to ring buffer
*     @author        ray.gong
*     @date              2013-5-21
*     @modify        fawn.fu @ 20160617
*     @param[in]        p_ring_buf ring buffer handle
*     @param[in]        ul_buf_len read data length
*     @param[out]    p_data_in point to the data write to ring buffer
*      @return          AUI_RNT_SUCCESS write data to ring buffer successful
*      @return          AUI_RTN_EINVAL  write data to ring buffer failed,because input parameters invalid
*      @return          OS_RING_WT_NO_BUF  the remain space in ring buffer is less than want to write length
*      @return          others  write data to ring buffer failed
*     @note
*
*/
AUI_RTN_CODE aui_common_ring_buf_wt(aui_ring_buf* p_ring_buf,unsigned long ul_buf_len,unsigned char *p_data_in)
{
    unsigned long ul_buf_remain=0;
    ENTER
    pthread_mutex_lock((pthread_mutex_t *)p_ring_buf->sem_ring);
    if((NULL==p_ring_buf->pby_ring_buf)||(NULL==p_data_in))
    {
        pthread_mutex_unlock((pthread_mutex_t *)p_ring_buf->sem_ring);
        LEAVE
        aui_rtn(AUI_RTN_EINVAL,NULL);
    }
    pthread_mutex_unlock((pthread_mutex_t *)p_ring_buf->sem_ring);
    if(AUI_RTN_SUCCESS!=aui_common_ring_buf_remain(p_ring_buf,&ul_buf_remain))
    {
        LEAVE
        aui_rtn(AUI_RTN_FAIL,NULL);
    }
    if(ul_buf_len>ul_buf_remain)
    {
        LEAVE
        aui_rtn(AUI_RTN_RING_WT_NO_BUF,NULL);
    }

    pthread_mutex_lock((pthread_mutex_t *)p_ring_buf->sem_ring);//AUI_TAKE_SEM(p_ring_buf->sem_ring);
    if(ul_buf_len<= p_ring_buf->ul_ring_buf_len-p_ring_buf->ul_ring_buf_wt)
    {
        MEMCPY(p_ring_buf->pby_ring_buf+p_ring_buf->ul_ring_buf_wt,p_data_in,ul_buf_len);
        //osal_cache_flush(p_ring_buf->pby_ring_buf+p_ring_buf->ul_ring_buf_wt,ul_buf_len);
        //-->debug
        //unsigned long i = 0;
        //int ret = MEMCMP(p_ring_buf->pby_ring_buf+p_ring_buf->ul_ring_buf_wt,p_data_in,ul_buf_len);
        //AUI_DBG("compare the ring buf and p_data_in, the result is: %d\n", ret);
        //for (i = 0; i < ul_buf_len; i++)
        //AUI_DBG("p_ring_buf[%ld]: %x, data_in[%ld]: %x\n", i, (unsigned int)(*p_ring_buf->pby_ring_buf+i), i,(unsigned int)(*p_data_in++));
        //<--debug end
        AUI_DBG("ring buf: %p, wt:%ld, rd:%ld\n", p_ring_buf->pby_ring_buf, p_ring_buf->ul_ring_buf_wt, p_ring_buf->ul_ring_buf_rd);
        p_ring_buf->ul_ring_buf_wt+=ul_buf_len;
        AUI_DBG("<after write> ring buf: %p, wt:%ld, rd:%ld\n", p_ring_buf->pby_ring_buf, p_ring_buf->ul_ring_buf_wt, p_ring_buf->ul_ring_buf_rd);
        if(p_ring_buf->ul_ring_buf_wt==p_ring_buf->ul_ring_buf_len)
        {
            AUI_DBG("rest ul_ring_buf_wt to 0.");
            p_ring_buf->ul_ring_buf_wt=0;
        }
    }
    else
    {
        MEMCPY(p_ring_buf->pby_ring_buf+p_ring_buf->ul_ring_buf_wt,p_data_in,p_ring_buf->ul_ring_buf_len-p_ring_buf->ul_ring_buf_wt);
        //osal_cache_flush(p_ring_buf->pby_ring_buf+p_ring_buf->ul_ring_buf_wt,p_ring_buf->ul_ring_buf_len-p_ring_buf->ul_ring_buf_wt);
        MEMCPY(p_ring_buf->pby_ring_buf,p_data_in +p_ring_buf->ul_ring_buf_len-p_ring_buf->ul_ring_buf_wt,
        ul_buf_len-(p_ring_buf->ul_ring_buf_len-p_ring_buf->ul_ring_buf_wt));
        //osal_cache_flush(p_ring_buf->pby_ring_buf,ul_buf_len-(p_ring_buf->ul_ring_buf_len-p_ring_buf->ul_ring_buf_wt));
        p_ring_buf->ul_ring_buf_wt=(ul_buf_len-(p_ring_buf->ul_ring_buf_len-p_ring_buf->ul_ring_buf_wt));
    }

    pthread_mutex_unlock((pthread_mutex_t *)p_ring_buf->sem_ring);//AUI_GIVE_SEM(p_ring_buf->sem_ring);
    LEAVE
    return AUI_RTN_SUCCESS;
}
#endif


AUI_RTN_CODE aui_find_dev_by_idx(aui_module_id dev_type,unsigned long ul_dev_idx,aui_hdl *p_aui_hdl)
{
    if(dev_type >= AUI_MODULE_LAST || !all_hdl_initialized || ( NULL == p_aui_hdl))
        return AUI_RTN_FAIL;

    struct all_hdl *head = all_hdl + dev_type;
    aui_dev_priv_data *data = NULL;
    
    pthread_mutex_lock(&m_aui_common_mutex);
    
    aui_list_for_each_entry(data, &head->list, list) {
        if (data->dev_idx == ul_dev_idx) {
            *p_aui_hdl = data;
            pthread_mutex_unlock(&m_aui_common_mutex);
            return AUI_RTN_SUCCESS;
        }
    }	
    
    pthread_mutex_unlock(&m_aui_common_mutex);	
    return AUI_RTN_FAIL;
}

AUI_RTN_CODE aui_dev_reg(aui_module_id dev_type, aui_hdl dev_hdl)
{
    if(!dev_hdl || dev_type>=AUI_MODULE_LAST)
        return AUI_RTN_FAIL;

    /* first time initialized list of each module */
    if (!all_hdl_initialized) {
        int i;
        
        for (i=0; i<AUI_MODULE_LAST; i++)
            AUI_INIT_LIST_HEAD(&all_hdl[i].list);
            
        all_hdl_initialized = 1;
    }
    
    struct all_hdl *head = all_hdl + dev_type;
    aui_dev_priv_data *data = (aui_dev_priv_data *)dev_hdl;
    /* check if already registered */
    aui_dev_priv_data *d = NULL;

    pthread_mutex_lock(&m_aui_common_mutex);
    
    aui_list_for_each_entry(d, &head->list, list) {
        if (d == dev_hdl || d->dev_idx == data->dev_idx) {
            pthread_mutex_unlock(&m_aui_common_mutex);
            aui_rtn(AUI_RTN_EINVAL,
                "device(type:%d,index:%d) already registered", dev_type, data->dev_idx);
        }		
    }

    aui_list_add(&data->list, &head->list);
    pthread_mutex_unlock(&m_aui_common_mutex);
    return AUI_RTN_SUCCESS;
}

AUI_RTN_CODE aui_dev_unreg(aui_module_id dev_type, aui_hdl dev_hdl)
{
    if(!dev_hdl || dev_type >= AUI_MODULE_LAST || !all_hdl_initialized)
        return AUI_RTN_FAIL;

    struct all_hdl *head = all_hdl + dev_type;
    aui_dev_priv_data *data = NULL;

    pthread_mutex_lock(&m_aui_common_mutex);

    aui_list_for_each_entry(data, &head->list, list) {
        if (data == dev_hdl) {
            aui_list_del(&data->list);
            pthread_mutex_unlock(&m_aui_common_mutex);
            return AUI_RTN_SUCCESS;
        }
    }
    
    pthread_mutex_unlock(&m_aui_common_mutex);
    return AUI_RTN_FAIL;
}

AUI_RTN_CODE aui_handle_set_magic_num(aui_module_id dev_type_id,aui_hdl handle)
{
    ((aui_dev_priv_data *)handle)->ul_dev_type_id=dev_type_id;
    ((aui_dev_priv_data *)handle)->ul_dev_magic_num =
        AUI_HANDLE_MAGIC_NUM+((aui_dev_priv_data *)handle)->ul_dev_type_id;

    return AUI_RTN_SUCCESS;
}

AUI_RTN_CODE aui_handle_check(aui_hdl handle)
{
    if(AUI_HANDLE_MAGIC_NUM+((aui_dev_priv_data *)handle)->ul_dev_type_id !=
       ((aui_dev_priv_data *)handle)->ul_dev_magic_num)
        aui_rtn(AUI_RTN_EINVAL,"\r\n Dev magic number err!");

    return AUI_RTN_SUCCESS;
}

