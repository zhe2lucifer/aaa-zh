/**@file
 *	(c) Copyright 2014-2999  ALi Corp. (alitech.com)
 *	All rights reserved
 *
 *	@file				aui_dsc_test.c
 *	@brief
 *
 *	@version			1.0
 *	@date				03/02/2014
 *	@revision			none
 *
 *	@author 			Vincent Pilloux <vincent.pilloux@alitech.com>, Terry Wu <terry.wu@alitech.com>
 */


/* system header */
#include <stdio.h>
#include <string.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <inttypes.h>

#include "aui_dsc.h"

#if SHARED_LIB

/* marco definition */
#define TEST_LEN 2

/* static variable definition */
static int32_t test_stream_id = 0;

/* global variable definition */
void * dsc_handle;
void * csa_handle;


uint8_t input_data[376] = {
0x47 ,0x01 ,0xF6 ,0xD0 ,0x9A ,0xB0 ,0xA9 ,0x96 ,0xEE ,0xC7 ,0x6C ,0x72 ,0x4B ,
0x79 ,0x48 ,0xFA ,0xA8 ,0x83 ,0xA9 ,0xBC ,0x8C ,0xD2 ,0xDA ,0xBC ,0x1D ,0x03 ,
0x32 ,0xC8 ,0x19 ,0x84 ,0x1E ,0xFE ,0xB5 ,0x1A ,0xCF ,0xCE ,0x98 ,0x42 ,0x51 ,
0xA9 ,0x66 ,0x86 ,0x1E ,0xA5 ,0x24 ,0x6E ,0x7E ,0x33 ,0xF1 ,0xAB ,0x35 ,0xAE ,
0x4E ,0xB7 ,0x2A ,0x8B ,0x43 ,0x1C ,0x8B ,0x4D ,0xAA ,0x5D ,0x7B ,0x18 ,0x94 ,
0xC6 ,0x61 ,0x19 ,0x6D ,0xA1 ,0xC2 ,0x4A ,0xAF ,0xA9 ,0xE1 ,0x4A ,0x0D ,0xA3 ,
0xA9 ,0x4F ,0xE9 ,0xA9 ,0xD9 ,0x3B ,0xD2 ,0xD7 ,0xC3 ,0x24 ,0xFC ,0xF4 ,0x05 ,
0x30 ,0x42 ,0xB4 ,0x33 ,0xC6 ,0x68 ,0x11 ,0xE5 ,0xE0 ,0x96 ,0x26 ,0x86 ,0xF5 ,
0x24 ,0x21 ,0xE3 ,0x8D ,0x4D ,0xC7 ,0x53 ,0xAC ,0xD5 ,0x34 ,0x0C ,0x3D ,0x36 ,
0xB6 ,0x36 ,0xE8 ,0xA4 ,0x76 ,0xA4 ,0x22 ,0x6A ,0x20 ,0x30 ,0x2B ,0x01 ,0x02 ,
0x87 ,0x77 ,0x4F ,0x46 ,0x6B ,0xD4 ,0x5C ,0xF6 ,0xD3 ,0xB4 ,0x5F ,0x22 ,0x5A ,
0x8F ,0x48 ,0xEB ,0xF2 ,0xBC ,0xF8 ,0xCB ,0xE5 ,0x95 ,0xBD ,0x35 ,0x4B ,0x95 ,
0x8C ,0x26 ,0x5F ,0x01 ,0x2E ,0x6E ,0xDE ,0x22 ,0x1D ,0xCF ,0xA2 ,0xBE ,0x03 ,
0x15 ,0x1C ,0xD3 ,0xF5 ,0x66 ,0x3B ,0x17 ,0x88 ,0x5A ,0x49 ,0xDE ,0x79 ,0x1F ,
0x4D ,0x18 ,0x9D ,0x92 ,0x61 ,0xC3 ,0x47 ,0x01 ,0xF6 ,0xD1 ,0x5F ,0x21 ,0xC8 ,
0xF8 ,0x09 ,0xF0 ,0xA2 ,0x71 ,0x25 ,0xCE ,0x1D ,0x6B ,0x35 ,0x65 ,0x5F ,0xE6 ,
0xBD ,0x26 ,0x53 ,0x6A ,0xE6 ,0x75 ,0x40 ,0xAA ,0xD9 ,0x25 ,0x15 ,0xD0 ,0xBD ,
0x60 ,0xAF ,0xCD ,0x47 ,0x2B ,0xE0 ,0x80 ,0xDC ,0x47 ,0x27 ,0xF4 ,0x1B ,0x85 ,
0x44 ,0x74 ,0x99 ,0x76 ,0x67 ,0xE1 ,0xD7 ,0x87 ,0x6B ,0x6E ,0x3C ,0x67 ,0x92 ,
0xD8 ,0x55 ,0x33 ,0xB8 ,0x1A ,0x33 ,0x89 ,0xE4 ,0xB7 ,0x80 ,0x08 ,0x34 ,0xF0 ,
0xE3 ,0xBD ,0xA8 ,0x7E ,0x41 ,0x61 ,0xA2 ,0xE9 ,0xB1 ,0x7F ,0x6F ,0x36 ,0x03 ,
0x21 ,0x29 ,0x2B ,0xC0 ,0x55 ,0xBF ,0xFB ,0x7D ,0xE8 ,0x3F ,0x0E ,0x68 ,0x93 ,
0x30 ,0xD6 ,0xA4 ,0xAB ,0xA2 ,0xE4 ,0xB9 ,0x15 ,0xFA ,0x30 ,0xD6 ,0xB3 ,0x2E ,
0x31 ,0x00 ,0x68 ,0x34 ,0x55 ,0x3A ,0xA0 ,0x27 ,0xC3 ,0xBC ,0xBA ,0x22 ,0xAE ,
0x6A ,0x15 ,0x92 ,0xBF ,0x25 ,0x56 ,0x60 ,0xFE ,0xC2 ,0xE4 ,0x35 ,0xEC ,0x24 ,
0xBF ,0x15 ,0xC7 ,0xF9 ,0x5E ,0x94 ,0x31 ,0xE8 ,0xB8 ,0x1E ,0xA7 ,0x46 ,0xC1 ,
0x10 ,0xC6 ,0x96 ,0x57 ,0x25 ,0x8B ,0xCB ,0x4F ,0x1A ,0x13 ,0x9B ,0x50 ,0xAD ,
0x0A ,0x38 ,0x09 ,0x4B ,0xC7 ,0x15 ,0xAF ,0x81 ,0xAE ,0x20 ,0x4E ,0xDD ,0xD9 ,
0x88 ,0xE5 ,0xF6 ,0x64 ,0x52 ,0xE0 ,0x4B ,0x58 ,0xDF ,0x4A ,0xC5 ,0x50
};

uint8_t out_data[376];

uint8_t standard_data[376] = {
0x47 ,0x01 ,0xF6 ,0x10 ,0x1C ,0xA7 ,0xB9 ,0x96 ,0xA0 ,0x46 ,0x00 ,0x34 ,0x23 ,
0x1F ,0x8C ,0xEC ,0x3D ,0x62 ,0xDE ,0xE4 ,0x71 ,0xCB ,0xA2 ,0x84 ,0xC1 ,0x09 ,
0xD8 ,0x5A ,0xC7 ,0xC3 ,0x36 ,0x34 ,0x66 ,0x01 ,0xA1 ,0xDA ,0xEB ,0x93 ,0xEE ,
0x68 ,0x90 ,0x52 ,0x1D ,0xC0 ,0x88 ,0x52 ,0x0C ,0x86 ,0x6C ,0xE3 ,0xC7 ,0x2C ,
0x05 ,0xD7 ,0x13 ,0xE9 ,0x21 ,0x57 ,0x31 ,0xFE ,0x70 ,0xA0 ,0xB8 ,0x05 ,0xF7 ,
0x34 ,0x33 ,0xAA ,0x01 ,0x73 ,0x10 ,0x2C ,0x2C ,0x8B ,0x62 ,0x00 ,0x6B ,0x57 ,
0x37 ,0x77 ,0x70 ,0x00 ,0x00 ,0x01 ,0x03 ,0x22 ,0x28 ,0x3B ,0x0D ,0x5F ,0x01 ,
0x6D ,0x14 ,0x27 ,0xC0 ,0x69 ,0x55 ,0xF7 ,0x15 ,0xC4 ,0xA9 ,0x7C ,0x43 ,0xC1 ,
0x75 ,0x75 ,0x73 ,0x5E ,0x3C ,0x2C ,0x4F ,0x0E ,0x5D ,0xD8 ,0xD4 ,0x00 ,0xD6 ,
0x8A ,0x19 ,0x07 ,0xAC ,0x07 ,0xF7 ,0xA0 ,0x1F ,0xCC ,0x26 ,0xAE ,0xA3 ,0xA1 ,
0xBC ,0x44 ,0xD2 ,0x80 ,0x3C ,0xA1 ,0x13 ,0x95 ,0xC5 ,0xB2 ,0x07 ,0xD1 ,0x4E ,
0x3A ,0x1B ,0xB8 ,0xA9 ,0xB0 ,0x78 ,0xFA ,0x90 ,0xD8 ,0x83 ,0xA1 ,0xEE ,0x16 ,
0x70 ,0xEA ,0x17 ,0x25 ,0xF7 ,0x22 ,0xB8 ,0x1C ,0xBA ,0x28 ,0x3A ,0x04 ,0x79 ,
0xF7 ,0xCA ,0xD8 ,0x7E ,0x63 ,0x6C ,0xB0 ,0xC7 ,0x3B ,0x6C ,0x16 ,0x1C ,0x2E ,
0x03 ,0xEE ,0xDC ,0x60 ,0xAE ,0x6C ,0x47 ,0x01 ,0xF6 ,0x11 ,0x90 ,0xCC ,0x1F ,
0x8D ,0xE8 ,0x5C ,0xCE ,0x65 ,0x14 ,0x27 ,0xC0 ,0x7F ,0x08 ,0x69 ,0xE7 ,0x0E ,
0xA2 ,0x83 ,0xD0 ,0x03 ,0x93 ,0x88 ,0xA2 ,0xAF ,0x0F ,0xFC ,0x82 ,0xAB ,0xD9 ,
0x20 ,0x3C ,0x20 ,0xC3 ,0xD7 ,0xC8 ,0x04 ,0x0A ,0xE6 ,0xD4 ,0x62 ,0x7A ,0x17 ,
0xDD ,0xC5 ,0x7D ,0xA5 ,0xA5 ,0x7B ,0x30 ,0xF8 ,0xE0 ,0x86 ,0x4F ,0x1E ,0xC0 ,
0x3E ,0x32 ,0x41 ,0xE3 ,0x5B ,0xA4 ,0x02 ,0x37 ,0x77 ,0xD3 ,0x2D ,0xA3 ,0x28 ,
0x45 ,0x53 ,0x0B ,0x9A ,0x33 ,0x40 ,0x3E ,0x17 ,0x00 ,0xBE ,0x8A ,0x0E ,0x83 ,
0xA8 ,0x53 ,0x89 ,0x67 ,0x8D ,0xEF ,0xB0 ,0x2E ,0x80 ,0x0C ,0xB7 ,0x3D ,0x38 ,
0x83 ,0x02 ,0xF7 ,0xFF ,0xD1 ,0x42 ,0x7C ,0xC5 ,0xD0 ,0x0B ,0xEC ,0xC5 ,0x01 ,
0xA8 ,0x49 ,0x1A ,0x8A ,0x0D ,0x03 ,0x1F ,0xB9 ,0xD9 ,0x41 ,0x44 ,0x94 ,0x87 ,
0xF9 ,0xF3 ,0x63 ,0x00 ,0x3D ,0x95 ,0x87 ,0x6B ,0xCC ,0x68 ,0x77 ,0x1D ,0x71 ,
0x82 ,0x13 ,0x19 ,0x45 ,0x9B ,0x8D ,0x18 ,0xE3 ,0x57 ,0xA2 ,0x6E ,0x28 ,0x0B ,
0x01 ,0x72 ,0xC1 ,0x20 ,0x01 ,0x1C ,0xFD ,0xB9 ,0xC6 ,0x0F ,0x83 ,0x7E ,0x01 ,
0x46 ,0x6D ,0xC7 ,0xEE ,0x93 ,0x76 ,0x38 ,0xC2 ,0x7C ,0x05 ,0xCD ,0x40 ,0xCE ,
0x2F ,0x39 ,0xBA ,0x73 ,0x20 ,0x1A ,0x51 ,0x42 ,0x66 ,0x24 ,0xB1 ,0x8E
};



/* init hardware device */
static alisl_retcode hw_init(void)
{
	alisl_retcode ret = 0;
	uint32_t dev_id;

	/* init descramble device */
	ret = alisldsc_dsc_construct(&dsc_handle);
	if (ret != 0)
	{
		printf("construct DSC fail.\n");
		return ret;
	}
	ret = alisldsc_dsc_open(dsc_handle);
	if (ret != 0)
	{
		printf("open DSC fail.\n");
		return ret;
	}

	/* init CSA device */
	ret = alisldsc_dsc_get_free_subdev(dsc_handle, CSA, &dev_id);
	if (ret != 0)
	{
		printf("get CSA free device id fail.\n");
		return ret;
	}
	ret = alisldsc_csa_construct(&csa_handle);
	if (ret != 0)
	{
		printf("construct CSA fail.\n");
		return ret;
	}
	ret = alisldsc_csa_open(csa_handle, dev_id);
	if (ret != 0)
	{
		printf("open CSA fail.\n");
		return ret;
	}

	return ret;
}


static alisl_retcode csa_set_clear_key(void)
{
	alisl_retcode ret = 0;
	CSA_INIT_PARAM csa_param;
	KEY_PARAM key_param;
	uint16_t pid[2] = {502, 602};
	uint32_t pid_len = 2;
	struct CSA_KEY key;
	uint32_t stream_id = 0;
	uint8_t ocw[8] = {0xFE, 0x17, 0x2C, 0x41, 0xA2, 0xE1, 0xD4, 0x57};
	uint8_t ecw[8] = {0xD4, 0x22, 0x82, 0x78, 0x1D, 0x28, 0x72, 0xB7};

	/* get free stream id */
	ret = alisldsc_dsc_get_free_stream_id(dsc_handle, CSA, &stream_id);
	if (ret != 0)
	{
		printf("get free stream id for CSA fail.\n");
		return ret;
	}
	else
	{
		test_stream_id = stream_id;
	}

	/* set CSA work mode */
	MEMSET(&csa_param, 0, sizeof(CSA_INIT_PARAM));
	csa_param.Dcw[0] = 0 ;
	csa_param.Dcw[1] = 1 ;
	csa_param.Dcw[2] = 2 ;
	csa_param.Dcw[3] = 3 ;
	csa_param.dma_mode = TS_MODE ;
	csa_param.key_from = KEY_FROM_SRAM ;
	csa_param.parity_mode = AUTO_PARITY_MODE0 ;
	csa_param.pes_en = 1;					/*not used now*/
	csa_param.scramble_control = 0 ;		/*dont used default CW*/
	csa_param.stream_id = stream_id;
	csa_param.version = CSA1 ;
	ret = alisldsc_csa_init(csa_handle, &csa_param);
	if (ret != 0)
	{
		printf("set CSA working mode fail.\n");
		return ret;
	}

	MEMSET(&key, 0, sizeof(struct CSA_KEY));
	MEMCPY(key.EvenKey, ecw, 8);		   /*even key*/
	MEMCPY(key.OddKey, ocw, 8); 		   /*odd key*/

	/* create CSA stream */
	MEMSET(&key_param, 0, sizeof(KEY_PARAM));
	key_param.ctr_counter = NULL ;
	key_param.init_vector = NULL ;
	key_param.key_length = 64;
	key_param.pid_len = pid_len;
	key_param.pid_list = pid;
	key_param.p_aes_iv_info = NULL ;
	key_param.stream_id = stream_id;
	key_param.force_mode = 0;
	key_param.p_csa_key_info = &key;
	ret = alisldsc_csa_create_crypt_stream(csa_handle, &key_param);
	if (ret != 0)
	{
		printf("create CSA stream fail.\n");
		return ret;
	}

	printf("create CSA success, stream_id = %d, key_param.handle = %d"
			".\n", stream_id, key_param.handle);
	return ret;
}

static void csa_decrypt_test()
{
	alisl_retcode ret = 0;
	uint8_t * input = input_data;
	uint8_t * output = out_data;

	ret = alisldsc_csa_decrypt(csa_handle, test_stream_id, input, output, TEST_LEN);
	if (ret != 0)
	{
		printf("CSA decrypt fail.\n");
	}
	if (MEMCMP(output, standard_data, 188*TEST_LEN) == 0)
	{
		printf("CSA decrypt right.\n");
	}
	else
	{
		printf("CSA decrypt wrong.\n");
	}
}



int main(int argc, char * argv[])
{
	unsigned long t;
	printf("First test OK!\n");
	test_stream_id = 0; 		/* init stream id */

	hw_init();
	csa_set_clear_key();
	csa_decrypt_test();
	return 0;
}

#else

int main(int argc, char * argv[])
{
	aui_hdl handle;
	aui_attr_dsc attr;
	unsigned long version;
	// 8 bytes odd key + 8 bytes even key
	uint8_t keys[16] = {0xFE, 0x17, 0x2C, 0x41, 0xA2, 0xE1, 0xD4, 0x57,
						0xD4, 0x22, 0x82, 0x78, 0x1D, 0x28, 0x72, 0xB7};

	printf("Starting DSC test\n");
	aui_dsc_version_get(&version);
	printf("DSC AUI version: %lu\n", version);

	aui_dsc_de_init(NULL, NULL);
	//attr.uc_dev_idx = ?;/** The index of devices */
	attr.dsc_data_type = AUI_DSC_DATA_PURE;
	attr.dsc_key_type = AUI_DSC_HOST_KEY_SRAM;
	attr.uc_algo = AUI_DSC_ALGO_CSA;
	attr.uc_mode = 0;
	attr.puc_key = keys;
	attr.ul_key_len = 16;
	attr.puc_iv_ctr = NULL;  // NULL allowed??
	attr.en_parity = AUI_DSC_PARITY_MODE_EVEN_PARITY_MODE;	// correct for test case??
	attr.en_residue = AUI_DSC_RESIDUE_BLOCK_IS_NO_HANDLE;
	attr.ts_pid = 0;			/* unusused in RAM to RAM configuration */
	attr.ul_key_pos = 0;	 /* unusused in RAM to RAM configuration */
	attr.ul_stream_id = 0;		  // TBD ??
	attr.ul_key_param_handle = 0; /* unusused in RAM to RAM configuration (no KL) */

	printf("aui_dsc_open...\n");
	if (aui_dsc_open(&attr, &handle)!=AUI_RTN_SUCCESS)
	{
		printf("Error calling aui_dsc_open()!\n");
		return -1;
	}
	printf("aui_dsc_attach_key_info2dsc...\n");
	if (aui_dsc_attach_key_info2dsc(handle, &attr)!=AUI_RTN_SUCCESS)
	{
		printf("Error calling aui_dsc_attach_key_info2dsc()!\n");
		return -1;
	}

	aui_dsc_close(handle);
	aui_dsc_de_init(NULL, NULL);
	return 0;
}

#endif
